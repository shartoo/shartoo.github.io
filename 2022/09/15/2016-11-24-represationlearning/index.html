<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="baidu-site-verification" content="93f8r6fzoB" />
<meta name="google-site-verification" content="TRFlJTt2XTd9bCvpogqNRWkuoxwFeOUBf8ouiChVFyQ" />
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/science_256px_1075043_easyicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/science_128px_1075043_easyicon.ico">
  <link rel="mask-icon" href="/images/stars.svg" color="#222">
  <meta name="google-site-verification" content="TRFlJTt2XTd9bCvpogqNRWkuoxwFeOUBf8ouiChVFyQ">
  <meta name="baidu-site-verification" content="93f8r6fzoB">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://shartoo.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="深度学习">
<meta property="og:type" content="article">
<meta property="og:title" content="深度学习：表征学习">
<meta property="og:url" content="https://shartoo.github.io/2022/09/15/2016-11-24-represationlearning/index.html">
<meta property="og:site_name" content="数据与算法">
<meta property="og:description" content="深度学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation1.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation15.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation16.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation2.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation3.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation11.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/repretation12.jpg">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation4.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation5.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation13.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation7.png">
<meta property="og:image" content="https://shartoo.github.io/images/blog/representation14.png">
<meta property="article:published_time" content="2022-09-15T08:16:12.750Z">
<meta property="article:modified_time" content="2022-09-15T08:16:12.750Z">
<meta property="article:author" content="shartoo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shartoo.github.io/images/blog/representation1.png">

<link rel="canonical" href="https://shartoo.github.io/2022/09/15/2016-11-24-represationlearning/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>深度学习：表征学习 | 数据与算法</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">数据与算法</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">重新出发</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shartoo.github.io/2022/09/15/2016-11-24-represationlearning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="shartoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="数据与算法">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深度学习：表征学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-15 16:16:12" itemprop="dateCreated datePublished" datetime="2022-09-15T16:16:12+08:00">2022-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">深度学习</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>概述</strong>：本章，我们首先讨论了表征学习的概念以及深度学习中表述学习的可用之处。我们讨论了学习算法在不同任务之间共享统计特性，包括使用无监督学习的信息来作监督学习任务。共享的表征可用于处理多领域问题，或者将已学习的知识转换到只有几个或者完全没有样本的但是包含表征的任务中。最后会回头讨论表述学习的成功的原因，起于分布式表述和深度表述的优势，终于数据处理的隐性假设，也即观测数据的隐藏促因。</p>
<p>机器学习中，一个好的表述方法可以使得后续的 学习任务更简单。因而，表述方法的选择通常依赖于后续学习任务的选择。</p>
<p>我们可以将使用监督学习方法的前馈网络看做一种学习表征的方法。一般网络最后一层是线性分类器，比如softmax线性回归分类，网络其他部分其实可以看做在给此分类器提供表征。比如，输入的特征可能是线性不可分，但是到最后隐藏层时变得线性可分了。</p>
<p>其他学习算法一般会细致地被设计为以某种特殊的方式具化其表征。比如，假若我们想学习使得密度评估方法更简单的表征，越多独立变量的表征越易于建模，所以我们的目标函数被设计成使表征向量V的元素尽可能独立。如同监督学习网络，非监督学习算法除了有个主要的训练目标，还会学习表述方法这个副产品。这个副产品用在多任务学习中，可以使其在各个任务之间共享。</p>
<p>表述学习的亮点在于，它可以提供一种执行半监督和无监督学习的方法。我们通常有大量无标签数据集和少量有标签的作为训练样本。<strong>在标签数据集中做的监督学习容易导致过拟合，半监督学习由于可以从无标签数据集中学习，可以有一定概率化解这种情况。</strong></p>
<h2 id="1-逐层贪婪的无监督预训练"><a href="#1-逐层贪婪的无监督预训练" class="headerlink" title="1 逐层贪婪的无监督预训练"></a>1 逐层贪婪的无监督预训练</h2><p> 无监督学习在深度神经网络历史中扮演重要角色，但是如今（2014年往后）广泛使用的CNN模型已<strong>不再</strong>使用逐层训练方式进行初始化。但是无监督学习仍然是今后深度学习领域的“圣杯”，是解决大量无标签数据集问题的利器。关于无监督学习的一段小变迁参考 <a target="_blank" rel="noopener" href="http://www.caffecn.cn/?/question/53">无监督逐层预训练目前是否还广泛应用于CNN的训练</a>。</p>
<p> 逐层贪婪的无监督预训练依赖于一个单层表述学习算法如RBM（关于RBM 可以参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhangchaoyang/articles/5537643.html">基于RBM的推荐算法</a>），一个单层自动编码器， 一个稀疏编码模型，或者其他学习潜在表征的模型。每一层使用无监督学习来预训练，以上一层的输出作为输入，并输出数据的另外一种表征，整个分布朝着更简单的方向。</p>
<p>更详细的无监督方法可以参考国内的一篇 <a target="_blank" rel="noopener" href="http://www.c-s-a.org.cn/ch/reader/create_pdf.aspx?file_no=20160801&flag=1&journal_id=cas&year_id=2016">无监督学习综述论文</a></p>
<p>特点：</p>
<ul>
<li><p><strong>贪婪</strong>：它基于贪婪算法，它独立地优化问题的解的方方面面，每次一个方面，而不是同时优化全局</p>
</li>
<li><p><strong>逐层</strong>：这些独立的方面都是网络的每一层，每次只训练其中一层，并且训练第 $i$ 层时会固定前面的网络层。</p>
</li>
<li><p><strong>无监督</strong>：每一层的训练都是使用无监督表述学习算法。</p>
</li>
<li><p><strong>预训练</strong>：它只是训练其他所有网络层之前的一小步。</p>
</li>
</ul>
<h3 id="1-1-无监督预训练何时以及为何有用"><a href="#1-1-无监督预训练何时以及为何有用" class="headerlink" title="1.1 无监督预训练何时以及为何有用"></a>1.1 无监督预训练何时以及为何有用</h3><p>许多任务中，逐层贪婪的无监督预训练可以在分类任务中减小测试误差。</p>
  <hr>
  **逐层贪婪无监督预训练算法**

<p>  假若：无监督学习算法 <strong>L</strong> ,接收训练样本集并返回一个编码器或者特征函数 $f$ 。</p>
<p>  原始输入数据是 $X$ ，每个样本为一行， $f^{(1)}(X)$ 是第一阶段的在数据 $X$ 上的输出编码器，它同时作为第二阶段无监督特征学习的输入。</p>
<p>  在微调阶段，我们使用一个学习函数 $T$ ，以一个初始函数 $f$ 作为输入，输入样本 $X$ ，然后返回调整后的函数。<br>  <hr></p>
<p>  无监督预训练方法结合两个不同的论据。<strong>首先，初始化参数的选择会对模型产生非常显著的正则化影响（往近一点说，它可以提高优化效果），其次，学习输入的分布可有助于学习如何将输入映射到输出</strong>。</p>
<p>第一个观点，初始化参数的选择对网络的正则化效果是很难理解。在预训练流行时，它被理解为局部性地初始化了一个模型，而这会导致网络陷入局部最优。现在我们认为网络不会被局部最小问题困扰。但是仍然有这种可能的情况，某些预训练初始化的网络在某些位置变得不可接近（进一步优化）。例如，某些区域minibatch的不同样本点的轻微变动会导致损失函数极大变动，或者某些区域Hessian矩阵几近无力，此时的梯度下降算法必须使用非常小的步长。然而，我们通过监督学习阶段预训练参数获得的特征难以精确控制，现在的办法都是使用一种近似无监督学习和监督学习的方法，而不是分开使用两种方法。如果想知道监督学习如何从无监督学习阶段如何保存优化信息而不太麻烦的话，可以将特征抽取的参数固定并只在学习的参数的顶层的分类器上使用监督学习。</p>
<p>另外一个观点，学习算法可以将无监督阶段学习到的信息用于监督学习阶段来提高算法。这个好理解，即无监督任务中的某些有用特征同时可用于监督学习任务。</p>
<p>以无监督预训练学习特征表述的观点来看，我们认为无监督预训练在初始特征表述十分贫乏时尤为有效。一个突出实例是词袋模型。以one-hot向量词表述并没有很丰富的信息，因为任意两个不同的one-hot词向量都是相同的距离(欧氏距离 $L^2$ 都是2)。学习的词袋表征天然的可以编码词之间的相似度。但是这一点对于图像没有太大用处。</p>
<p>考虑下其他因素。例如，无监督预训练在要学习的函数极端复杂时十分有用。无监督学习与正则化处理的不同之处在于，它不会偏移（正则化方法会在目标函数上做变动）学习器去挖掘简单的表述函数，而是挖掘无监督学习所需的特征表述函数。</p>
<p> 撇开以上，我们分析下无监督预训练能带来提供的实例，并解释其中原因。无监督预训练通常用于提升分类器性能，并能减小测试误差。但是，无监督预训练不止是作用于分类，它能提升优化性能，而不是仅仅正则化。比如，它能同时提升训练和测试深度自编码网络的重构误差。神经网络训练过程，每次都会拟合成不同函数。<strong>经过无监督预训练的神经网络会在解空间的相同区域收敛，但是普通网络可能会停留在不同区域</strong>。下图演示了这种现象:</p>
<p> <img src="/images/blog/representation1.png" alt="无监督预训练与普通网络的对照"></p>
<p>图中预训练网络达到更小的区域，说明预训练可以减小评估过程的方差（更稳定）。</p>
<p>那么，无监督预训练是如何起正则化作用呢？我们的假设是它可以使得学习算法挖掘观测数据背后的相关特征方向。</p>
<p><strong>缺点一</strong>：无监督预训练的缺点是，它需要两个独立训练阶段，即需要更多的参数，其结果便是很难在事前预知训练效果。同时（与分两阶段进行的无监督预训练对比）使用有监督和无监督学习时，通常只需要一个超参数，即在无监督学习的代价函数上添加一个额外项。该额外项用以衡量无监督目标函数对有监督模型的正则化影响。可确信的是，额外项系数减小，正则化效果也会相应减弱。</p>
<p><strong>缺点二</strong>：第二个不足之处是，分成两个独立阶段时，每个阶段都会有其独立的超参数。通常无法从第一阶段来预测第二阶段的性能，因此从第二阶段的反馈来更新第一阶段的超参数时存在很长的滞后。<strong>其中的一个基本原则是，使用监督学习阶段的验证数据集的误差去选择预训练阶段的超参数。</strong><br>现实之中，一些超参数，比如预训练迭代次数，使用在无监督目标函数上的使用提前终止的方法，虽不完美，但是用于监督目标函数上易于计算。</p>
<p>如今，无监督预训练基本被遗忘，除了自然语言处理领域。其中的词的one-hot向量表征没有承载任何相似信息，并且会存在大量的无标签数据集。此时，预训练的优势是，可以在海量无标签数据集上预训练一次，学习到一个较好的表征（通常是词语，也可以是句子），然后使用这个表征或者微调之后的，用于训练集样本较少的监督学习任务。</p>
<h3 id="1-2-无监督学习的四种实现模型"><a href="#1-2-无监督学习的四种实现模型" class="headerlink" title="1.2 无监督学习的四种实现模型"></a>1.2 无监督学习的四种实现模型</h3><p> <strong>自动编码器（auto-encoders）</strong></p>
<p> 一个典型的自编码例子如下图所示, 从可见层到第一个隐含层的转换相当于是一个编码过程(encoder), 从第一个隐含层到输出层相当于一个解码过程(decoder)。 自编码过程使用的一般都是无标签数据, 输入据(input data)经过第一层变换(encoder), 就会被进行一定程度的抽象, 得到一个更深层的编码(code), 然后可以通过第二层变换(decoder)得到一个近似于输入数据(input data)的输出数据(output data)。</p>
<p> <img src="/images/blog/representation15.png"></p>
<p> 优点：</p>
<ul>
<li><p>简单技术：重建输入</p>
</li>
<li><p>可堆栈多层</p>
</li>
<li><p>直觉型，且基于神经科学研究</p>
</li>
</ul>
<p> 缺点：</p>
<ul>
<li><p>贪婪训练每一层</p>
</li>
<li><p>没有全局优化</p>
</li>
<li><p>比不上监督学习的表现</p>
</li>
<li><p>层一多会失效</p>
</li>
<li><p>输入的重建可能不是学习通用表征的理想度量（metric）</p>
</li>
</ul>
<p> <strong>聚类学习（Clustering Learning）</strong></p>
<p> 所周知，受限玻尔兹曼机（RBMs）、深度玻尔兹曼机（DBMs）、深度信念网络（DBNs）难以训练，因为解决其配分函数（partition function）的数值难题。因此它们还未被普遍用来解决问题。</p>
<p>优点：</p>
<ul>
<li><p>简单技术：聚类相似输出</p>
</li>
<li><p>可被多层堆栈</p>
</li>
<li><p>直觉型，且基于神经科学研究</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>贪婪训练每一层</p>
</li>
<li><p>没有全局优化</p>
</li>
<li><p>在一些情况下，比不上监督学习的表现</p>
</li>
<li><p>层数增加时会失效，收益递减</p>
</li>
</ul>
<p><strong>生成模型（generative models）</strong></p>
<p>生成模型，尝试在同一时间创建一个分类（识别器或编码器）网络和一个生成图像（生成模型）模型。这种方法起源于 Ian Goodfellow 和 Yoshua Bengio（参见论文：Generative Adversarial Networks）的开创性工作。</p>
<p>下面是系统框架图：</p>
<p> <img src="/images/blog/representation16.png"></p>
<p> 优点：</p>
<ul>
<li><p>整个网络的全局训练（global training）</p>
</li>
<li><p>代码和应用简单明了</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>难以训练和转化（conversion）</p>
</li>
<li><p>在某些情况下，与有监督学习的表现相似</p>
</li>
<li><p>需论证展示方法（representation）的可用性（这是所有无监督算法面临的问题）</p>
</li>
</ul>
<h2 id="2-迁移学习和领域自适应"><a href="#2-迁移学习和领域自适应" class="headerlink" title="2 迁移学习和领域自适应"></a>2 迁移学习和领域自适应</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p> <strong>迁移学习和领域自适应：</strong>指的是在某种情况下学习到的设置(比如概率分布 $P_1$ )迁移到另外一种情形下(概率分布 $P_2$ )。这其实是前面部分的思想推广，前面将无监督学习任务和监督学习任务之间的表征做了迁移。考虑到大部分数据或任务是存在相关性的，所以通过transfer learning我们可以将已经学到的parameter 分享给新模型从而加快并优化模型的学习不用像之前那样learn from zero.</p>
<p> 在迁移学习中，学习者必须同时进行两个或多个不同任务，但是我们假设其中用于解释变量 $P_1$ 的许多因子与另外一个学习参数 $P_2$ 的许多变量相关。这可以理解为，在监督学习上下文中，输入是相同的，但是实质目标可能不同。比如，我们可能在第一步的参数设置时学习了一些视觉领域集合，比如猫和狗，然后在第二步的参数设置中学习了另外一个视觉领域，比如蚂蚁和黄蜂。如果第一步的学习设置（从 $P_1$ 抽样）时有非常多的数据，那么这可能有助于从包含很少样本的 $P_2$ 中学习表征。许多视觉类别共享了低层次的比如边和形状这些概念，几何上的改变，其效果较小。 一般来说，如果存在可以被被不同设置或任务共同使用的特征，这对应了在多种设置中的潜在因子，那么通过表征学习可以完成迁移学习，多任务学习和领域自适应。</p>
<p> 但有的时候，不同任务之间共享的不是输入的语义而是输出的语义。比如，语音识别系统需要在输出层产生合法的句子，但是靠近输入层的浅层网络可能需要识别相同意音素的不同版本或者取决于讲话人的亚音素发声。此时，共享靠近输出层的高层网络并有一些特定任务预处理显得更有意义。如下图:</p>
<p> <img src="/images/blog/representation2.png" alt="迁移学习"></p>
<p> 【多任务学习或迁移学习架构，对所有任务输出变量y是相同语义，而输入变量x有不同意义】</p>
<p>在领域自适应的相关实例中，每种设置的任务相同（包括从输入映射到输出的优化过程），但是输入分布可能不同。比如，语音分析任务中，需要分析情感倾向（正面或负面）。如果情感预测器的训练集用的是媒体预料，比如书籍、视频和音乐，但是用于分析的却是用户对电子产品，如电视和手机，领域适应问题就会出现。可以想象，存在一个隐藏函数，它能区分评论的情感倾向，积极、消极、中立，但是不同领域之间表达情感倾向的词汇和样式却不相同，这使得跨领域的泛化有难度。不过一些应用在情感分析中的简单的无监督预训练（领域适应）被证明很有效。</p>
<p>一个相关问题是概念错位，我们可以看成一种随时间变迁，其数据分布逐步变动的迁移学习。概念错位和迁移学习都可以看做一种特殊形式的多任务学习。其中“多任务学习”特指监督学习任务，迁移学习更多的时候用于描述无监督学习和增强学习。</p>
<p>以上所有，目标都是利用第一步配置来抽取信息，这些信息可能有用在第二步的配置（参数）或者直接预测了第二步的配置。<strong>表征学习的核心观点是，相同的表征可同时用于两步的配置</strong>。</p>
<p>前面提到过，用于迁移学习的无监督深度学习在机器学习竞赛中很有效。竞赛中的第一步，每位选手会被给予根据第一步配置（分布 $P_1$ ）的数据集，某些分类的数据样例。选手必须根据这些来学习较好的特征空间（从原始数据输入映射到其他表征），这样，当将这些学习到的转换</p>
<p><strong>迁移学习的两个极端</strong> 是：<em><strong>one-shot</strong></em> 学习和 <em><strong>zero-shot</strong></em> 学习(也称为<em><strong>zero-data</strong></em> 学习)。对于 <em>one-shot</em> ,迁移学习中只有一个标签样本，而 <em>zero-shot</em> 则所有样本都是无标签的。</p>
<p>one-shot学习是可能的，因为表征学习可以在第一阶段干净地区分隐藏的分类。在迁移学习阶段，只需要有一个有标签的样本，用以推测许多测试样本的可能标签，围绕在表征空间的某点聚类簇中心的其他数据点可能是同一标签。从某种程度上说，对应于这些不变特性的变异因素已经在表征空间被彻底与其他因素分离，并且已经学习到哪些因素是决定样本隶属某个分类的重要特性。关于<code>one-shot</code>学习的，可以参考源码 <a target="_blank" rel="noopener" href="https://github.com/tristandeleu/ntm-one-shot">源码</a>,论文<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1605.06065v1.pdf">论文</a>,数据<a target="_blank" rel="noopener" href="https://github.com/brendenlake/omniglot">数据</a></p>
<p>在zero-shot 学习配置的实例中，考虑以下场景，某位学者已经阅读了大量的文本，然后去解决物体识别问题。倘若物体被足够充分的数据描述，识别一个不曾见过的该物体图像也是可能的（人类的学习）。比如，阅读了一只猫有四只腿和尖耳朵，学习者可能会猜出一幅猫的图像，而不需要见过猫。</p>
<p><strong>只有其他（额外）信息足够充分时，zero-shot和one-shot才有可能。</strong> 考虑一种zero-shot场景，包含了三个变量，正常的输入 $x$ ，正常的输出或者目标 $y$，以及一个描述任务的随机变量 $T$。模型被训练为评估条件分布 $p(y\mid x,T)$ ，其中T是一个描述模型该如何起作用的描述。在识别猫的例子中，是已经阅读了猫，输出是一个二分变量y,其中 $y&#x3D;1$ 表示yes, $y&#x3D;0$ 代表no。任务变量T 表示要回答的问题，例如‘‘这个图像中是否有猫？” 如果训练集包含和T 在相同空间的无监督对象样本，我们也许能够推断未知的T 实例的含义。在我们的例子中，没有提前看到猫的图像而去识别<br>猫，拥有一些未标记的文本数据包含句子诸如‘‘猫有四条腿’’ 或‘‘猫有尖耳朵’’ 是很重要的。</p>
<p>zero-shot学习要求T被表示为某种泛化的形式。例如，T不仅仅是指示对象类别的one-shot。通过使用关于每个类别的词，学习到的词嵌入表征，论文提出了对象类别的分布式表示。</p>
<p>一种类似的现象出现在机器翻译中。我们已知一种语言中的单词，和从非语言语料库中学习到的关系；另一方面，我们已经翻译了一种语言中的单词与另一种语言中的单词相关的句子。即使我们可能没有将语言X中的单词A翻译成语言Y中的单词B的标记样本，那么我们可以泛化并猜出单词A的翻译，这是由于我们已经学习了语言X和Y的分布式表示，并且通过两种语言相匹配句子组成的训练样本，产生了关联于两个空间的链接（可能是双向的）。如果所有的三种成分（两种表述形式和他们之间的关系）是联合学习的，那么这种迁移学习将是成功的。</p>
<p>zero-shot是一种特殊形式的迁移学习。同样的原理可以解释如何能执行多模态学习(multimodal learning)，学习两种模态的表示，和一种模态中的观察x 和另一种模态中的观察y 组成的对(x; y) 之间的关系（通常是一个联合分）(Srivastavaand Salakhutdinov, 2012)。通过学习所有的三组参数（从x 到它的表示，从y 到它的表示，以及两个表示之间的关系），一个表示中的概念被锚定在另一个表示中，反之亦然，从而可以有意义地推广到新的对组。这个过程如图15.3所示。</p>
<p><img src="/images/blog/representation3.png" alt="迁移学习"><br>关于迁移学习应用到机器翻译中，我们可以参考谷歌翻译的得 <a target="_blank" rel="noopener" href="http://www.im2maker.com/news/20161123/f0995a12c3328fc8.html">谷歌发布 Zero-Shot 神经机器翻译系统：AI 巴别塔有望成真</a>								</p>
<h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例"></a>2.2 实例</h3><p> <strong>1.游戏之间的参数迁移</strong></p>
<p>   Deepmind的作品 progressive neural network. <a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1606.04671v3.pdf"> progressive neural network</a> 文章里将三个小游戏Pong, Labyrinth, Atari 通过将已学其一的游戏的parameter 通过一个 lateral connection feed 到一个新游戏。有一个视频展示了其结果 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=aWAP_CWEtSI">游戏之间迁移学习参数</a> 。迁移学习的一个简单框架如下图</p>
<p>  <img src="/images/blog/representation11.png" alt="迁移学习"></p>
<p> 迁移学习的一篇博客介绍参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21470871">从虚拟到现实，迁移深度增强学习让机器人革命成为可能！</a></p>
<p><strong>2. 图像之间迁移学习</strong></p>
<p> 最近比较火的风格图像生成，<code>tensorflow</code>,<code>caffe</code>,<code>torch</code>都出了对应的开源代码。比如 tensorflow的 <a target="_blank" rel="noopener" href="https://github.com/anishathalye/neural-style">eural-style</a>。<br>  该代码的原理论文来自 <a target="_blank" rel="noopener" href="http://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf">图像风格迁移学习</a></p>
<p>   <img src="/images/blog/repretation12.jpg" alt="迁移学习"></p>
<p>上图中，输入图像被表示为CNN不同阶段地的被过滤后的图像集合,处理层次越深，过滤器的数量越多，尺寸越小（CNN中使用了最大池化），这导致了每一层的神经元总数减少。</p>
<ul>
<li><p><strong>内容重构：</strong>上图中，仅仅使用已知的输入图像在每一层的网络得响应来可视化了CNN不同阶段处理，上图重构的是输入图像在原始<strong>VGG网络</strong>在<code>conv1 2</code> (a),<code>1conv2 2</code> (b), <code>conv3 2</code> (c), <code>conv4 2</code> (d) 和 <code>conv5 2</code> (e)上的重构信息。</p>
</li>
<li><p><strong>风格重构：</strong>在原始CNN网络的顶层激活函数，使用的是输入图像的质地信息作为特征。风格表征计算不同CNN网络层之间的不同特征的相关性。这可以构建图像，其风格与输入图像上不断增长的特征尺寸相仿，同时丢弃场景中全局布局信息。</p>
</li>
</ul>
<p>关于风格的计算参考该论文。</p>
<h2 id="3-半监督解释因果关系"><a href="#3-半监督解释因果关系" class="headerlink" title="3 半监督解释因果关系"></a>3 半监督解释因果关系</h2><p> 如何确定一种表征比另外一种更好？我们假设，最理想的表征的特征能够追溯到观测数据分布的本质。特征空间中不同的特征或方向源于不同的促因，从而使得表征有能力将这些促因区分。如果y是产生x的重要原因之一，那么 $p(x)$ 可能是计算 $p(y\mid x)$ 的一种良好表征形式。</p>
<p> 在表征学习的其他方法中，我们通常会考虑易于建模的表征，比如全部实体是稀疏的或者相互独立的。完全独立不相关的并不一定易于建模。但是，更进一步看，目前的AI任务都是用无监督表征来促进半监督学习。其实两者是相通的，一旦我们获知观测数据的潜在促因，通常很容易分离样本的独立属性。</p>
<p> 首先，我们看看如果半监督学习 $p(x)$ 无益于于学习 $p(y\mid x)$  。 如果样本 $p(x)$ 是正态分布的，我们想学习  $f(x)&#x3D;E[y\mid x]$ 。很显然，仅仅从观测训练集x，无法提供给我们任何有用信息。</p>
<p> 接下来，对照看下半监督学习如何变得有用。假若x是由不同部件混合，不同的y部件会构成不同的x值，如下图所示。如果构成x的部件y是完全独立的，那么对 $p(x)$ 建模即精确调和每个部件，每种分类的单标签样本将足以学习 $p(y\mid x)$ 。如果更进一步思考，是什么将 $p(y\mid x)$ 和 $p(x)$ 搭上联系。</p>
<p><img src="/images/blog/representation4.png" alt="迁移学习"></p>
<p>【此图展示的是由三个构件混合构成的x的密度，部件标识了潜在的解释因子y。由于混合构件都是统计显著的，以不使用标签样本的无监督方式建模p(x)已经能够获取因子y了】</p>
<p>如果y与x的某个促因紧密相关， 那么 $p(y)$ 和 $p(y\mid x)$ 也会是强相关的，并且作为一种半监督学习策略，与变量潜在因子相关的无监督表征学习也会是十分有用的。</p>
<p>考虑到我们的假设是y是x的促因之一，现在让h代表所有的促因。真实的生成过程可以通过以下有向图模型获得，h作为x的祖先（在图中的关系是h–&gt;x）</p>
<p>$$<br>   p(h,x) &#x3D;p(x\mid h)p(h)<br>$$</p>
<p>其结果是，数据具有边际概率</p>
<p>$$<br>   p(x)&#x3D;E_hp(x\mid h)<br>$$</p>
<p>从以上直观的观察，我们可以得出，表述x的最好的模型是可以揭示真正结构的一个，其中h是解释x中观测变量的潜在变量。以上讨论的完美的表征学习应该重现这些潜在因子。如果y是其中之一（或者与其中之一紧密相关），那么将很容易从这种表述中学习预测y。我们也可以看到，给定x，y的条件分布是由贝叶斯法则约束的（上述等式）。</p>
<p>因此边缘概率 $p(x)$ 是与条件概率 $p(y\mid x)$和前者的结构信息紧密相关的。因而，基于不同情形对应的假设，半监督学习有助于提升性能。</p>
<p>一个重要的研究问题是，大部分观测数据是由极其多的潜在促因形成的。假设 $y&#x3D;h_i$ ,但是无监督学习器并不知道是哪个  $h_i$ 。学习表征时学习器的暴力解决方案是尝试所有的生成因子 $h_i$ ，并将它们组合，因而为了易于从 <code>h</code> 预测 <code>y</code> 时，我们应该不考虑哪个 $h_i$ 与 <code>y</code> 有关联。</p>
<p>暴力解并不可取，因为不可能穷尽所有或者大部分的变量促因在观测数据上面的影响。例如，在图像处理中，表征应该对背景中所有物体编码吗？这是个有记录的心理学现象，人类无法感知与他们手头任务不直接相关的变化。半监督学习的一个比较前沿的研究是，决定在不同情形下对什么进行编码。当前，处理大量潜在促因的两种策略是同时使用<strong>监督学习</strong>信号和<strong>无监督学习</strong>信号，这样模型就会选择捕捉与变量最相关的促因，或者，如果只有纯粹的无监督学习就会使用更大的表征。</p>
<p>无监督学习中的一种应急策略是修改最显著潜在促因的定义。以经验来说，自动编码和生成模型被训练成优化一个固定的标准，通常是类似均方误差。这种固定的标准决定了那种促因会被当做最显著的。例如，均方误差应用到图像像素时，隐含地指定了只有当大量像素的亮度发生改变时潜在促因才是显著的。如果我们要解决的问题是与小物体交互，将会出问题。下图演示的是一个机器人任务，机器人的自动编码器无法学习对小乒乓球编码。但是，对于大一点的物体，比如棒球，却是可以的，这是因为根据军方误差，棒球更显著。</p>
<p><strong>其他关于显著的定义</strong>。例如，一组以高度可识别的模式组合起来的像素组，即便组合模式不是与亮度或暗度相关的，这种模式也被认为是极度显著的。其中一中重新定义显著的实现方法是使用最近提出的称为<strong>生成对抗网络</strong>。此方法中，生成模型被训练成欺骗前馈分类器。前馈分类器尝试将所有来自生成模型的所有样本识别为负样本，而所有来自训练集的为正样本 。这种组织架构中，任何前馈网络能够识别的结构模式都被认为是高度显著的。论文(Lotter et al. (2015)表明使用均方误差训练成生模型，生成人类头部图像的网络生成的人头经常会忽略掉耳朵，但是如果使用对抗网络架构的话则可以成功生成耳朵。因为耳朵与面部其他地方比起来并不是特别明亮或者暗，对于均方误差来说它们并不显著，但是它们的高度可识别形状和连续的坐标位置对于前馈网络来说易于学习和识别，这对于生成对抗网路来说是足够显著的。</p>
<p><img src="/images/blog/representation5.png" alt="对抗网络生成人的头部图像"></p>
<p>学习潜在促因的一个好处是，如果真实的生成过程中<strong>x</strong>是效果，而<strong>y</strong>是促因，那么模型 $p(x\mid y)$ 对于 $p(y)$ 上的改变是健壮的。如果因果关系逆转，可能就不是真实的，因为根据贝叶斯法则， $p(x\mid y)$ 对于 $p(y)$ 的变化是敏感的。对抗网络另外一个生成人类语音的例子是 <a target="_blank" rel="noopener" href="https://deepmind.com/blog/wavenet-generative-model-raw-audio/">GoogleDeepMind模拟人语音读文本</a></p>
<h2 id="4-分布式表征"><a href="#4-分布式表征" class="headerlink" title="4 分布式表征"></a>4 分布式表征</h2><p> 分布式表征的概念是，表征由许多元素组成，每个元素都是独立的，这是表征学习中最重要的工具。分布式表征可以用 $n$ 个特征的 $k$ 个不同值来描述 $k^n$ 个不同概念。如我们所见，有多个隐藏神经元的神经网络以及有多个显著变量的概率模型都使用了分布式表征策略。再引入一个额外的观测。许多深度学习算法都是假设隐藏神经元可以学习表征潜在促因，那些潜在促因解释 了样本数据。分布式表征天然适用于这种方法，因为表征空间的每个方向可以对应到不同潜在配置变量的值。</p>
<p> 一个分布式表征的样本是一个有 $n$ 个二分特征的向量，它可以有 $2^n$ 个配置，每个配置潜在的对应了输入空间的不同区域。如下图：</p>
<p> <img src="/images/blog/representation13.png" alt="表征学习"></p>
<p> 可以与符号表示对比来开，输入是与单个符号或分类相关。如果词典中有n个符号，我们可以想象n个特征检测器，每个检测器只负责其 相关领域的分类。此时的表征空间只有n个不同配置，刻画了输入空间的n个不同区域，如下图。</p>
<p> <img src="/images/blog/representation7.png" alt="表征学习"></p>
<p>这种符号表述也称为 one-hot表征，它可以被一个n个字节的互斥的0(1)向量（n个字节中只有一个是1）描述。符号表征是非分布式表征的一种特殊例子，非分布式表征是指其表述可能会包含许多实体，但是对每个实体并没有有意义的实质独立控制。</p>
<p>基于非分布式表征学习的算法有以下：</p>
<ul>
<li><p><strong>聚类方法</strong>：包括K均值聚类，每个输入点被当做一个聚类</p>
</li>
<li><p><strong>KNN算法</strong>：对于某个输入会有相关的一个或几个模板或原型。</p>
</li>
<li><p><strong>决策树</strong>：给定输入，只有一个叶子节点是激活的。</p>
</li>
<li><p><strong>高斯混合和专家混合</strong>：模板（聚类中心）或者专家现在与一个激活度相关。如同KNN，每个输入表述了多个值，但是这些值不能很好的与其他值区分开。</p>
</li>
<li><p><strong>基于n-grams的语言或翻译模型</strong>：上下文集合（符号序列）按照一个树形结构的前缀区分。叶节点可能对应的是最后两个单词为 $w_1$ 和 $w_2$ 的，例如，参数会独立的为树种每个叶子评估（可能有些是共享的）。</p>
</li>
</ul>
<p>对于这些非分布式表征算法，其输出不是恒定的，而是会比临接区域影响的。参数数量（或者样本）和区域数量之间的关系是可以线性定义的。</p>
<p>一个区分分布式表征与符号表征的重要概念是，不同概念之间由于需要共享属性而需要泛化。对于纯粹的符号”cat” 和”dog” 是两个完全不同的符号。但是，如果将其中之一以某种形式的分布式表征表示，那么许多关于猫的事情可能被泛化为狗(都是动物？四条腿？)。例如，我们的分布式表征可能包含实体，如“有毛”或者“腿的数量”，这样猫和狗的这两个实体的值是一样的。基于词的分布式表征的神经语言模型，比直接在词的one-hot表征的模型要生成的更好。分布式表征引发了丰富的相似空间，这种语义相近概念与距离的概念很像，这是符号表征所不具备的属性。</p>
<p>何时使用分布式表征作为学习算法的一部分有概率优势？—当看起来很复杂的结构可以用很少的参数表述的时候。一些传统的非分布式表征学习算法，只是因为平滑假设而泛化，该假设认为如果 $u \approx v$ ,那么要学习的目标函数 $f$ 也会有属性 $f(u)\approx f(v)$  。有多种方式来公式化这种假设，但结果是如果我们有样本 $(x,y)$  其中 $f(x)\approx y$ ,那么我们会选择一个评估器 $\hat f$ 可以近似满足在输入 $x+\epsilon $ 处移动时，函数 $\hat f$ 结果不变这一受限条件。这种假设是有用的，但是会引入维度问题：为了在许多不同区间增加或减小的目标函数，若有N个不同区间，我们可能至少需要N样本。我们可以将每个区域看成一个分类或者符号，我们可以学习任意从符号到值的解码。 然而，这样我们就没法泛化来学习新的符号或分类了。</p>
<p>幸运的话，目标函数中除了平滑之外，可能会有些规律。例如，最大池化的卷积神经网络可以无视物体坐标位置去识别，甚至即使物体的空间变换与输入空间的平滑转换对应不上。</p>
<p>我们来检验一个分布式表征学习的特殊例子，即通过对输入值的线性函数的阈值做二分特征抽取（达到某个阈值为1，否则该特征为0）。此表征中的每个二分特征将空间 $R^d$ 划分为一对半空间，如上上一张图（ $h_1,h_2,h_3$ 那张）。大到指数级的n个交叉点对应了的半空间决定了分布式表征学习器可以分辨的区域。空间 $R^d$ 中的n个超平面可以生成多少个区域？论文 (Pascanu et al., 2014b)证明此二分特征表征可以分辨得区域数量为</p>
<p>$$<br> \sum _{j&#x3D;1}^d(_j ^d)&#x3D;O(n^d)<br>$$</p>
<p>我们可以看到区域数是输入数量的指数级增长，隐藏神经元数量以多项式级增长。</p>
<p>这为分布式表征的泛化能力提供了一种几何参数上的解释：$O(nd)$ 个参数（空间 $R^d$ 中n个线性阈值特征）可以代表输入空间的 $O(n^d)$ 的不同区域。如果我们不对任何数据做任何假设，并使用一种表征，每个区域只有一个唯一的符号标识，并且每个符号标识都有独立的参数来识别空间 $R^d$ 中对应的那部分，然后识别 $O(n^d)$ 个区域需要 $O(n^d)$ 个样本。更一般的说，倾向于使用分布式表征的论据在于可以拓展到使用非线性阈值单元（二分0-1函数）。此时的参数处于这种情形，如果k个参数的参数转换可以学习输入空间中r个区域，其中 $k&lt;&lt;r$ 。使用更少参数可以表述模型意味着，我们有更少的参数去拟合，这样就需要极少训练样本就可以泛化得很好。关于模型基于分布式表征可以泛化得很好的更深远的论据是，尽管它可以唯一的编码非常多的不同区域，它所能表征的容量是有限的。例如，神经网络的线性阈值神经元的VC维度仅有 $O(wlogw)$，其中 $w$ 是权重数。这种限制产生的原因是，尽管我们可以给表征空间分配非常多唯一的符号标识，我们也无法绝对的全部使用所有的标识空间，同时也不能用线性分类器任意学习从表征空间 $h$ 到输出 $y$ 的函数。（线性分类器的组成的神经元只能拟合线性函数）。结合线性分类器的分布式表征只能识别线性可分的分类。我们要学习的分类只能是类似，所有图像集中的全部绿色物体，图像中所有的汽车集合，而不是那种需要非线性XOR逻辑的分类。比如，我们不能将数据集分为，所有的红色汽车和绿色卡车作为一类，所有的绿色汽车和红色卡车作为一类。</p>
<p>我们可以考想象，学习某种特征时不必看见所有其他特征的配置。论文Radfordet al. (2015)展示了一个生成模型，该模型学习人的面部表征，表征空间中不同方向可以捕获变量不同的潜在促因。下图演示了，表征空间中一个方向对应了某个人是男人或女人，另一个方向对应的是此人是否有戴眼镜。</p>
<p><img src="/images/blog/representation14.png" alt="表征学习8"></p>
<p>这些特征都是自动发现的，没有任何先验知识。隐藏神经元分类器没必要有标签：如果任务需要类似的特征，所求的目标函数上的梯度下降算法会自然而然地从语义上去学习感兴趣特征。我们可以学习男性和女性的差异，也可以学习是否有戴眼镜，而不必对所有其他n-1个其他特征上所有的值的组合做抽样来进行符号化。（类似VSM模型，但是不需要事先知道整个词典）。这种形式的概率独立性允许我们生成训练期间没有出现的人的新的特征配置（新的特征）。</p>
<h2 id="5-源于深度的指数增益"><a href="#5-源于深度的指数增益" class="headerlink" title="5 源于深度的指数增益"></a>5 源于深度的指数增益</h2><p> 多层感知机都是广义近似，一些函数的表述使用深层网络可以比浅层网络要指数级减少。这种模型尺寸上的较少可以提高统计效率。此处，我们会陈述，将分布式表征应用到其他类型的模型会获得的类似的效果。</p>
<p> 上一节看到的一个生成模型的例子，可以学习人脸图像的描述性隐藏因子，包括人脸的性别和是否有戴眼镜。生成模型完成此类任务是基于深度神经网络。浅层网络是没法学习这种图像像素到抽象的描述性因子之间的复杂关系的。在这个以及其他AI任务中，为了生成与高度非线性的输入高度相关的数据，这类因子可以被几乎完全独立的选取。我们认为，这需要<strong>深度</strong>分布式表征，更高层次的特征（看做输入的函数）或者因子（看做生成促因）都是通过许多非线性组合获得的。</p>
<p> 在许多不同的设置中已经证明，通过许多非线性和一种层次的特征的二次使用组成的组织计算，可以在统计效率上得到指数级的增长。许多不同网络（比如，饱和的非线性，Boolean门，Sum&#x2F;product，或者RBF神经元）使用一层隐藏层的可以被广义近似呈现。给予足够多的隐藏神经元，一个广义近似模型族可以拟合非常多类别的函数（包括所有的连续函数）。但是隐藏神经元的数量需要非常多。关于深度架构的表述能力的理论结果表明，存在可以被深度为 $k$ 的深层架构有效地表述的函数族，但是会需要输入数量的指数倍的隐藏神经元和完全的深度（2到k-1的深度）。</p>
<h2 id="6-提供线索以挖掘潜在促因"><a href="#6-提供线索以挖掘潜在促因" class="headerlink" title="6 提供线索以挖掘潜在促因"></a>6 提供线索以挖掘潜在促因</h2><p>再回头看看我们的原始问题，什么样的表征比另一个更好？第三小节提出了一种答案，完美的表征应该是不扭曲生成数据的变量的潜在促因（变量由促因组合，变量一般是数据的某一种特征），特别是与我们的应用相关的促因。表征学习的大部分策略是基于引入线索来帮助学习找到变量的潜在促因。<br>监督学习提供的是很强的线索：对于每个 $x$ 都有个对应标签 $y$ ，这通常直接指定了变量的至少一个促因的值。更一般的说，为了利用大量无标签数据，表征学习利用了其他的，非直接的，与潜在促因相关的提示。这种提示以隐含的学习算法设计者的先验知识的形式，指导学习器。一般认为正则化策略有助于获得很好的泛化。尽管无法获得通用的监督正则策略，深度学习的目标是找到一个相对通用的正则化策略，可以应用于相对广泛的AI任务。</p>
<p>下面提供了一些通用的正则化策略。以下列表虽不不是详尽无遗，但也给出了一些集中的例子。</p>
<ul>
<li><strong>平滑：</strong>这是对神经元 $d$ 和某个非常小的数 $\epsilon$,有 $f(x+\epsilon d)\approx f(x)$ 。这种假设允许学习器从训练样本泛化到输入空间附近的某些点。许多机器学习算法继承 了这种思路，但不足以克服维度灾难。</li>
</ul>
<p><strong>线性性：</strong>许多学习算法假设一些变量间的关系是线性的。这允许算法做远超观测数据的预测，但是有时候会导致极限预测。<strong>大部分简单的机器学习算法不做平滑假设，而作线性假设。</strong>这些其实是不同的假设：有很多权重的线性函数应用到高维空间可能并不平滑。</p>
<p><strong>多解释因子：</strong>许多表征学习算法基于一种假设：数据是被多个解释因子生成的，并且在给定每个这些因子的状态时大部分任务可以轻易地解决。</p>
<p><strong>促因：</strong>模型以这种方式构建：它将变量的经学习好的表征 $h$ 描述的因子看做观测数据 $x$ 的促成原因，但反之则不成立。如第三小节讨论的，这是半监督学习的优势，并且使得学习好的模型在潜在促因的分布产生变动或应用到新任务时更健壮。</p>
<p><strong>深度或解释因子的层次组织：</strong>高层次的抽样概念可以被一些简单的概念组合来定义，以形成一种层次。以另外一种观点来看，用深度架构表述我们的思想可以通过多步程序完成，其中每一步都是回头处理前一步输出结果。</p>
<p><strong>任务间共享（促因）因子：</strong>许多任务中的上下文，对应不同 $y_i$ 的变量共享了相同的输入 $x$ 或者每个任务都是与全局输入 $x$ 的一个子集或者函数 $f^{(i)}(x)$ 相关，假设是每个 $y_i$ 与某个源于相同相关因子 $h$ 的共同池的不同的子集相关。因为这些子集之间的重叠，借助共享的中间表征 $P(h\mid x)$ 学习所有的 $P(y_i\mid x)$ 可以在多个任务之间共享统计特性（比较抽象，应该是学习到的表征有共同的统计特性）。</p>
<p><strong>歧管：</strong>（要理解<strong>歧管</strong>可以参考排气歧管，它是与发动机气缸体相连的，将各缸的排气集中起来导人排气总管的，带有分歧的管路。对它的要求主要是，尽量减少排气阻力，并避免各缸之间相互干扰）概率大量浓缩（集中），集中的区域都是局部相连的并且只占用很小的容量。在连续变量场景，这些区域可以用比原始数据少得多的维度的低维复用</p>
<p><strong>天然聚类簇：</strong>许多机器学习算法假设输入空间中的每个相连的歧管可以被分配到单个类别。数据可能位于许多不相连的歧管，但是每个歧管里面的类别数依然是常量。这种假设促使各种各样的机器学习算法产生，包括切线传播，双反向传播，歧管切线分类器和对抗训练。</p>
<p><strong>时间和空间的相干性：</strong>慢特征分析和相关算法做的假设是，大部分重要的描述因子会随时间缓慢变动，或者，与预测原始观测数据如像素值相比，真正的潜在的描述因子更容易被预测。</p>
<p><strong>稀疏性：</strong>大部分特征想必与大部分输入描述不相关，没必要使用全量的输入特征，当表征一只猫时不必检测大象和卡车。因此，任意特征大多情况下可以被描述为“出现”或“没出现”。</p>
<p><strong>简化因子依赖：</strong>在好的高层次表征中，特征之间是通过简单的依赖来彼此相关的。最简单的可能是边缘独立，$P(h)&#x3D;\prod _iP(h_i)$ ，但是被浅层自动编码器捕获的线性依赖也是可信的假设。这可以在许多物理定律中看到，在学习到的表征上插入线性预测器或因子分解的先验知识就是一种假设。</p>
<br>
 [知乎 刘诗昆 关于迁移学习的回答](https://www.zhihu.com/question/41979241)
 [机器之心 一篇文章入门无监督学习](http://it.sohu.com/20161030/n471784836.shtml)

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/15/2013-04-01-dataming-PCA/" rel="prev" title="数据挖掘方法之一：主成份分析">
      <i class="fa fa-chevron-left"></i> 数据挖掘方法之一：主成份分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/15/2017-03-11-autoseg-bylungvolumne/" rel="next" title="Morphological Segmentation and Partial Volume of Solid Pulmonary Lesions in Thoracic CT Scans">
      Morphological Segmentation and Partial Volume of Solid Pulmonary Lesions in Thoracic CT Scans <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%80%90%E5%B1%82%E8%B4%AA%E5%A9%AA%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="nav-number">1.</span> <span class="nav-text">1 逐层贪婪的无监督预训练</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%97%A0%E7%9B%91%E7%9D%A3%E9%A2%84%E8%AE%AD%E7%BB%83%E4%BD%95%E6%97%B6%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BD%95%E6%9C%89%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 无监督预训练何时以及为何有用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 无监督学习的四种实现模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%A2%86%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94"><span class="nav-number">2.</span> <span class="nav-text">2 迁移学习和领域自适应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8D%8A%E7%9B%91%E7%9D%A3%E8%A7%A3%E9%87%8A%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">3 半监督解释因果关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E5%BE%81"><span class="nav-number">4.</span> <span class="nav-text">4 分布式表征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%BA%90%E4%BA%8E%E6%B7%B1%E5%BA%A6%E7%9A%84%E6%8C%87%E6%95%B0%E5%A2%9E%E7%9B%8A"><span class="nav-number">5.</span> <span class="nav-text">5 源于深度的指数增益</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8F%90%E4%BE%9B%E7%BA%BF%E7%B4%A2%E4%BB%A5%E6%8C%96%E6%8E%98%E6%BD%9C%E5%9C%A8%E4%BF%83%E5%9B%A0"><span class="nav-number">6.</span> <span class="nav-text">6 提供线索以挖掘潜在促因</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="shartoo"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">shartoo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shartoo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'c656cd038e01f710e260',
      clientSecret: 'e6de2ccaaf0f7069292125b8f50e27f25b95810d',
      repo: 'shartoo.github.io',
      owner: 'shartoo',
      admin: ['shartoo'],
      id: '143d062d13f65ff530f1ec4061e15103',
        language: '',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
</body>
</html>
